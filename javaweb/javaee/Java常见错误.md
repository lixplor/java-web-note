# Java常见错误

## 常见进制数表示方式

* 2进制
	- 规则: `0b`开头, 后面数字范围为`0~1`
	- `0b00000001`
* 8进制
	- 规则: `0`开头, 后面数字范围为`0~7`
	- `07`
* 10进制
	- 规则: `1~9`开头, 后面数字范围为`0~9`
	- `123`
* 16进制
	- 规则: `0x`或`0X`开头, 后面数字范围为`0~9`及`a~f`
	- `0xff`


## 运算符

### 按位操作

* 按位操作符用来操作基本数据类型中的bit, 即二进制位. 按位操作符会对两个参数中对应的位执行布尔运算
* 规则: 
	- `&`: 按位与. 两个都为1才为1, 否则为0
		- `1 & 1 = 1`
		- `1 & 0 = 0`
		- `0 & 1 = 0`
		- `0 & 0 = 0`
	- `|`: 按位或. 只要有一个为1则为1, 否则为0
		- `1 | 1 = 1`
		- `1 | 0 = 1`
		- `0 | 1 = 1`
		- `0 | 0 = 0`
	- `^`: 按位异或. 如果不同为1, 相同则为0
		- `1 ^ 1 = 0`
		- `1 ^ 0 = 1`
		- `0 ^ 1 = 1`
		- `0 ^ 0 = 0`
	- `~`: 按位非(取反), 1则0, 0则1
		- `~1 = 0`
		- `~0 = 1`


### 位移操作符

* 位移操作符操作二进制的bit, 只能处理整数类型
* 对`char`, `byte`, `short`进行位移, 则会先将其转换为`int`类型, 得到的结果也是`int`类型
* `<<`: 向左移动几位
* `>>`: (有符号)向右移动几位
	- 若符号为正, 则在高位插入`0`
	- 若符号为负, 则在高位插入`1`
* `>>>`: (无符号)向右移动几位
	- 无论正负, 都在高位插入`0`


### `a *+ b`

* `a *+ b`相当于`a * (+b)`
* `a *- b`相当于`a * (-b)`


### `=`赋值和`==`比较相等

* `while(a = b)`
	- 小括号中的表达式结果必须是boolean类型, 而`a = b`是一个赋值, 而非判断是否相等. 所以只有当a和b是boolean类型时结果才是boolean类型. 如果是其他类型, 则会在编译时期报错提示类型不符


### 用于跳转的标签

* Java中没有`goto`, 但可以使用标签, 结合`break`和`continue`使用, 实现类似其他语言中`goto`的作用, 本质不是跳转, 而是中断循环
* 标签的语法格式:
	- 定义标签: `标签名:`
	- 使用标签:
		- `break 标签名;`
		- `continue 标签名;`
* 标签的作用
	- 中断循环并跳转到标签处开始执行代码
	- 可以利用标签中断多层嵌套的循环
* 标签必须在循环之前使用, 标签和循环之间不能写任何语句, 否则会导致找不到标签



## 数据类型

### 字面值常量后加字母的问题

* 字母可以使用大写或小写, 但小写容易看错, 所以推荐使用大写
* long类型字面值常量: `10000000L`
* float类型字面值常量: `1.23F`
* double类型字面值常量: `3.14D`
	- D可以不加, 小数默认为double类型


## 垃圾回收

### 垃圾回收机制

* 引用计数器算法
	- 原理: 
		- 每个对象都含有一个引用计数器, 当有引用连接到该对象时, 计数器+1, 当引用离开作用域或被置为null, 引用计数器-1. 在程序运行过程中, 垃圾回收器在含有全部对象的列表上遍历, 当发现某个对象的引用计数为0时, 就释放该对象占用的控件
	- 优点: 
		- 简单
	- 缺点: 
		- 速度慢
		- 如果两个对象之间存在循环引用, 而没有其他额外引用, 则这两个对象都应该被回收, 但此时这两个对象的引用计数器却不为0, 这会导致无法回收
		- 此算法一般只用于讲解垃圾回收, 并没有任何垃圾回收器采用这种方式
* 标记清理算法(Mark-Sweep)
	- 原理: 
		- 分为标记阶段和清理阶段. 先遍历所有引用, 找到一个存活的对象后, 就给对象设置一个标记. 该过程不会回收任何对象. 当全部标记完成后, 会将没有标记的对象释放.
	- 优点: 
		- 思想简单
		- 不占用额外空间
	- 缺点: 
		- 清理后的剩余的堆空间是不连续的, 容易产生内存碎片
* 停止复制算法(Stop-Copy)
	- 原理: 
		- 先暂停程序, 然后将所有存活的对象从当前堆复制到另一个堆. 复制时重新规划内存. 将原堆一次性清理掉
	- 优点: 
		- 清理后内存空间是连续紧凑的. 
	- 缺点:
		- 垃圾回收时, 程序会被暂停. 
		- 当复制到新堆后, 因为复制需要占用更多空间以及时间, 效率较低
* 标记整理算法(Mark-Compact)
	- 原理:
		- 在标记阶段和标记清理算法一样, 将存活的对象标记出来. 然后并不直接清理, 而是将存活的对象复制到新堆中, 同时重新规划内存. 然后将原堆一次性清理掉. 相当于结合了标记清理和复制算法
	- 优点:
		- 只将存活的对象复制到新堆中, 比停止复制算法节省内存
		- 同时重新规划内存, 比标记清理算法产生的内存碎片更少
	- 缺点:
* 分代收集算法
	- 原理:
		- 根据对象存活的生命周期, 将堆内存划分为老年代(Tenured Generation)和新生代(Young Generation), 方法区中是永久代(Permanet Generation). 生命周期短或占用内存小的对象分配在新生代, 生命周期长或占用内存大的对象分配在老年代. 新生代采用复制算法, 老年代采用标记整理算法.
	- 优点:
		- 垃圾回收策略灵活
		- 目前JVM多采用这种算法

		
### 回收相关方法

* `System.gc();`
	- 强制垃圾回收器开始回收垃圾
* `finalize();`
	- 当该对象被回收时会调用此方法
	- 但直接调用此方法并不会导致对象被回收
* `obj = null;`
	- 将对象的引用置为null, 从而在垃圾回收机运行时可以将该对象回收
* 重复不断的大量的创建对象, 也会触发垃圾回收器回收垃圾





